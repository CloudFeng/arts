## ARTS之旅（23周）

### Algorithm

#### 问题描述

本周做的习题是[234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)：
给定一个单链表，判断其是否是回文。

例1：
<pre>
Input: 1->2
Output: false
</pre>

例1:
<pre>
Input: 1->2->2->1
Output: true
</pre>

#### 解题思路与代码实现

1. 堆栈法

遍历链表，将其值存入栈中，然后再次遍历链表时比较栈顶元素是否与链表中的值一样，不一样则不是回文，否则是。

- 代码实现

```Java
public boolean isPalindrome(ListNode head) {
    if (null == head || null == head.next) {
        return true;
    }
    // loop the linked list, store its value into stack 
    Stack<Integer> stackInt = new Stack<Integer>();
    ListNode currNode = head;
    while (currNode != null) {
        stackInt.push(currNode.val);
        currNode = currNode.next;
    }
    currNode = head;
    while (currNode != null) {
        if (stackInt.isEmpty()) {
            return false;
        }
        if (stackInt.pop() != currNode.val) {
            return false;
        }
        currNode = currNode.next;
    }
    return stackInt.isEmpty();
}
   
```

- 复杂度分析

    + 时间复杂度为 O(n), n为链表的长度
    + 空间复杂度: O(n)

2. 快慢指针法 + 链表反转

利用快慢指针法找到中间节点，然后反转右边的子链表，比对左子链表和右子链表。

- 代码实现

```Java
public boolean isPalindrome(ListNode head) { 
    if (null == head || null == head.next) {
        return true;
    }
    ListNode pFast = head;
    ListNode pSlow = head;
    while (pFast != null && pFast.next != null) {
        pFast = pFast.next.next;
        pSlow = pSlow.next;
    }
    // odd linked list,the middle of it is  pSlow.next
    if (pFast != null) {
        pSlow = pSlow.next;
    }
    
    // reverse right list: [pSlow ...]
    pSlow = reverseList(pSlow);
    while (pSlow != null) {
        if (head.val != pSlow.val) {
            return false;
        }
        head = head.next;
        pSlow = pSlow.next;
    }
    return true;
}

private ListNode reverseList(ListNode head) {
    if (null == head || null == head.next) {
        return head;
    }
    ListNode preNode = null;
    while (head != null) {
        ListNode nextNode = head.next;
        head.next = preNode;
        preNode = head;
        head = nextNode;
    }
    return preNode;
}
```

- 复杂度分析

    + 时间复杂度为 O(n), n为链表的长度
    + 空间复杂度: O(1)

---

### Review

---

### Tip

---

### Share

----
